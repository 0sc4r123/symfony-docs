.. index::
   single: Cache

HTTP Cache
==========

The nature of rich web applications means that they're dynamic. No matter
how efficient your application, each request will always contain more overhead
than serving a static file.

And for most Web applications, that's fine. Symfony is lightning fast, and
unless you're doing some serious heavy-lifting, each request will come back
quickly without putting too much stress on your server.

But as your site grows, that overhead can become a problem. The processing
that's normally performed on every request should be done only once. This
is exactly what caching aims to accomplish.

Caching on the Shoulders of Giants
----------------------------------

The most effective way to improve performance of an application is to cache
the full output of a page and then bypass the application entirely on each
subsequent request. Of course, this isn't always possible for highly dynamic
websites, or is it? In this chapter, you'll see how the Symfony cache
system works and why this is the best possible approach.

The Symfony cache system is different because it relies on the simplicity
and power of the HTTP cache as defined in the `HTTP specification`_. Instead of
reinventing a caching methodology, Symfony embraces the standard that defines
basic communication on the Web. Once you understand the fundamental HTTP
validation and expiration caching models, you'll be ready to master the Symfony
cache system.

For the purposes of learning how to cache with Symfony, the
subject is covered in four steps:

#. A :ref:`gateway cache <gateway-caches>`, or reverse proxy, is
   an independent layer that sits in front of your application. The reverse
   proxy caches responses as they're returned from your application and answers
   requests with cached responses before they hit your application. Symfony
   provides its own reverse proxy, but any reverse proxy can be used.

#. :ref:`HTTP cache <http-cache-introduction>` headers are used
   to communicate with the gateway cache and any other caches between your
   application and the client. Symfony provides sensible defaults and a
   powerful interface for interacting with the cache headers.

#. HTTP :ref:`expiration and validation <http-expiration-validation>`
   are the two models used for determining whether cached content is *fresh*
   (can be reused from the cache) or *stale* (should be regenerated by the
   application).

#. :doc:`Edge Side Includes </cache/esi>` (ESI) allow HTTP cache to be used
   to cache page fragments (even nested fragments) independently. With ESI,
   you can even cache an entire page for 60 minutes, but an embedded sidebar
   for only 5 minutes.

Since caching with HTTP isn't unique to Symfony, many articles already exist
on the topic. If you're new to HTTP caching, Ryan
Tomayko's article `Things Caches Do`_ is *highly* recommended . Another in-depth resource is Mark
Nottingham's `Cache Tutorial`_.

.. index::
   single: Cache; Proxy
   single: Cache; Reverse proxy
   single: Cache; Gateway

.. _gateway-caches:

Caching with a Gateway Cache
----------------------------

When caching with HTTP, the *cache* is separated from your application entirely
and sits between your application and the client making the request.

The job of the cache is to accept requests from the client and pass them
back to your application. The cache will also receive responses back from
your application and forward them on to the client. The cache is the "middle-man"
of the request-response communication between the client and your application.

Along the way, the cache will store each response that is deemed "cacheable"
(See :ref:`http-cache-introduction`). If the same resource is requested again,
the cache sends the cached response to the client, ignoring your application
entirely.

This type of cache is known as a HTTP gateway cache and many exist such
as `Varnish`_, `Squid in reverse proxy mode`_, and the Symfony reverse proxy.

.. index::
   single: Cache; Types of

Types of Caches
~~~~~~~~~~~~~~~

A gateway cache isn't the only type of cache. In fact, the HTTP cache headers
sent by your application are consumed and interpreted by up to three different
types of caches:

* *Browser caches*: Every browser comes with its own local cache that is
  mainly useful for when you hit "back" or for images and other assets.
  The browser cache is a *private* cache as cached resources aren't shared
  with anyone else;

* *Proxy caches*: A proxy is a *shared* cache as many people can be behind a
  single one. It's usually installed by large corporations and ISPs to reduce
  latency and network traffic;

* *Gateway caches*: Like a proxy, it's also a *shared* cache but on the server
  side. Installed by network administrators, it makes websites more scalable,
  reliable and performant.

.. tip::

    Gateway caches are sometimes referred to as reverse proxy caches,
    surrogate caches, or even HTTP accelerators.

.. note::

    The significance of *private* versus *shared* caches will become more
    obvious when caching responses containing content that is
    specific to exactly one user (e.g. account information) is discussed.

Each response from your application will likely go through one or both of
the first two cache types. These caches are outside of your control but follow
the HTTP cache directions set in the response.

.. index::
   single: Cache; Symfony reverse proxy

.. _`symfony-gateway-cache`:
.. _symfony2-reverse-proxy:

Symfony Reverse Proxy
~~~~~~~~~~~~~~~~~~~~~

Symfony comes with a reverse proxy (also called a gateway cache) written
in PHP. Enable it and cacheable responses from your application will start
to be cached right away. Installing it is just as easy. Each new Symfony
application comes with a pre-configured caching kernel (``AppCache``) that
wraps the default one (``AppKernel``). The caching Kernel *is* the reverse
proxy.

To enable caching, modify the code of a front controller to use the caching
kernel::

    // web/app.php
    require_once __DIR__.'/../app/bootstrap.php.cache';
    require_once __DIR__.'/../app/AppKernel.php';
    require_once __DIR__.'/../app/AppCache.php';

    use Symfony\Component\HttpFoundation\Request;

    $kernel = new AppKernel('prod', false);
    $kernel->loadClassCache();
    // wrap the default AppKernel with the AppCache one
    $kernel = new AppCache($kernel);

    $request = Request::createFromGlobals();

    $response = $kernel->handle($request);
    $response->send();

    $kernel->terminate($request, $response);

The caching kernel will immediately act as a reverse proxy - caching responses
from your application and returning them to the client.

.. caution::

    If you're using the :ref:`framework.http_method_override <configuration-framework-http_method_override>`
    option to read the HTTP method from a ``_method`` parameter, see the
    above link for a tweak you need to make.

.. tip::

    The cache kernel has a special ``getLog()`` method that returns a string
    representation of what happened in the cache layer. In the development
    environment, use it to debug and validate your cache strategy::

        error_log($kernel->getLog());

The ``AppCache`` object has a sensible default configuration, but it can be
finely tuned via a set of options you can set by overriding the
:method:`Symfony\\Bundle\\FrameworkBundle\\HttpCache\\HttpCache::getOptions`
method::

    // app/AppCache.php
    use Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache;

    class AppCache extends HttpCache
    {
        protected function getOptions()
        {
            return array(
                'debug'                  => false,
                'default_ttl'            => 0,
                'private_headers'        => array('Authorization', 'Cookie'),
                'allow_reload'           => false,
                'allow_revalidate'       => false,
                'stale_while_revalidate' => 2,
                'stale_if_error'         => 60,
            );
        }
    }

.. tip::

    Unless overridden in ``getOptions()``, the ``debug`` option will be set
    to automatically be the debug value of the wrapped ``AppKernel``.

Here is a list of the main options:

``default_ttl``
    The number of seconds that a cache entry should be considered fresh when no
    explicit freshness information is provided in a response. Explicit
    ``Cache-Control`` or ``Expires`` headers override this value (default: ``0``).

``private_headers``
    Set of request headers that trigger "private" ``Cache-Control`` behavior on
    responses that don't explicitly state whether the response is ``public`` or
    ``private`` via a ``Cache-Control`` directive (default: ``Authorization``
    and ``Cookie``).

``allow_reload``
    Specifies whether the client can force a cache reload by including a
    ``Cache-Control`` "no-cache" directive in the request. Set it to ``true`` for
    compliance with RFC 2616 (default: ``false``).

``allow_revalidate``
    Specifies whether the client can force a cache revalidate by including a
    ``Cache-Control`` "max-age=0" directive in the request. Set it to ``true`` for
    compliance with RFC 2616 (default: ``false``).

``stale_while_revalidate``
    Specifies the default number of seconds (the granularity is the second as the
    Response TTL precision is a second) during which the cache can immediately
    return a stale response while it revalidates it in the background (default:
    ``2``); this setting is overridden by the ``stale-while-revalidate`` HTTP
    ``Cache-Control`` extension (see RFC 5861).

``stale_if_error``
    Specifies the default number of seconds (the granularity is the second) during
    which the cache can serve a stale response when an error is encountered
    (default: ``60``). This setting is overridden by the ``stale-if-error`` HTTP
    ``Cache-Control`` extension (see RFC 5861).

If ``debug`` is ``true``, Symfony automatically adds an ``X-Symfony-Cache``
header to the response containing useful information about cache hits and
misses.

.. sidebar:: Changing from one Reverse Proxy to another

    The Symfony reverse proxy is a great tool to use when developing your
    website or when you deploy your website to a shared host where you cannot
    install anything beyond PHP code. But being written in PHP, it cannot
    be as fast as a proxy written in C. That's why it is highly recommended you
    use Varnish or Squid on your production servers if possible. The good
    news is that the switch from one proxy server to another is easy and
    transparent as no code modification is needed in your application. Start
    easy with the Symfony reverse proxy and upgrade later to Varnish when
    your traffic increases.

    For more information on using Varnish with Symfony, see the
    :doc:`How to use Varnish </cache/varnish>` cookbook chapter.

.. note::

    The performance of the Symfony reverse proxy is independent of the
    complexity of the application. That's because the application kernel is
    only booted when the request needs to be forwarded to it.

.. index::
   single: Cache; HTTP

.. _http-cache-introduction:

Introduction to HTTP Caching
----------------------------

To take advantage of the available cache layers, your application must be
able to communicate which responses are cacheable and the rules that govern
when/how that cache should become stale. This is done by setting HTTP cache
headers on the response.

.. tip::

    Keep in mind that "HTTP" is nothing more than the language (a simple text
    language) that web clients (e.g. browsers) and web servers use to communicate
    with each other. HTTP caching is the part of that language that allows clients
    and servers to exchange information related to caching.

HTTP specifies four response cache headers that are looked at here:

* ``Cache-Control``
* ``Expires``
* ``ETag``
* ``Last-Modified``

The most important and versatile header is the ``Cache-Control`` header,
which is actually a collection of various cache information.

.. note::

    Each of the headers will be explained in full detail in the
    :ref:`http-expiration-validation` section.

.. index::
   single: Cache; Cache-Control header
   single: HTTP headers; Cache-Control

The Cache-Control Header
~~~~~~~~~~~~~~~~~~~~~~~~

The ``Cache-Control`` header is unique in that it contains not one, but various
pieces of information about the cacheability of a response. Each piece of
information is separated by a comma:

.. code-block:: text

    Cache-Control: private, max-age=0, must-revalidate

    Cache-Control: max-age=3600, must-revalidate

Symfony provides an abstraction around the ``Cache-Control`` header to make
its creation more manageable::

    // ...

    use Symfony\Component\HttpFoundation\Response;

    $response = new Response();

    // mark the response as either public or private
    $response->setPublic();
    $response->setPrivate();

    // set the private or shared max age
    $response->setMaxAge(600);
    $response->setSharedMaxAge(600);

    // set a custom Cache-Control directive
    $response->headers->addCacheControlDirective('must-revalidate', true);

.. tip::

    If you need to set cache headers for many different controller actions,
    you might want to look into the FOSHttpCacheBundle_. It provides a way
    to define cache headers based on the URL pattern and other request
    properties.

Public vs Private Responses
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Both gateway and proxy caches are considered "shared" caches as the cached
content is shared by more than one user. If a user-specific response were
ever mistakenly stored by a shared cache, it might be returned later to any
number of different users. Imagine if your account information were cached
and then returned to every subsequent user who asked for their account page!

To handle this situation, every response may be set to be public or private:

*public*
    Indicates that the response may be cached by both private and shared caches.

*private*
    Indicates that all or part of the response message is intended for a single
    user and must not be cached by a shared cache.

Symfony conservatively defaults each response to be private. To take advantage
of shared caches (like the Symfony reverse proxy), the response will need
to be explicitly set as public.

.. index::
   single: Cache; Safe methods

Safe Methods
~~~~~~~~~~~~

HTTP caching only works for "safe" HTTP methods (like GET and HEAD). Being
safe means that you never change the application's state on the server when
serving the request (you can of course log information, cache data, etc).
This has two very reasonable consequences:

* You should *never* change the state of your application when responding
  to a GET or HEAD request. Even if you don't use a gateway cache, the presence
  of proxy caches means that any GET or HEAD request may or may not actually
  hit your server;

* Don't expect PUT, POST or DELETE methods to cache. These methods are meant
  to be used when mutating the state of your application (e.g. deleting a
  blog post). Caching them would prevent certain requests from hitting and
  mutating your application.

.. _http-cache-defaults:

Caching Rules and Defaults
~~~~~~~~~~~~~~~~~~~~~~~~~~

HTTP 1.1 allows caching anything by default unless there is an explicit
``Cache-Control`` header. In practice, most caches do nothing when requests
have a cookie, an authorization header, use a non-safe method (i.e. PUT, POST,
DELETE), or when responses have a redirect status code.

Symfony automatically sets a sensible and conservative ``Cache-Control``
header when none is set by the developer by following these rules:

* If no cache header is defined (``Cache-Control``, ``Expires``, ``ETag``
  or ``Last-Modified``), ``Cache-Control`` is set to ``no-cache``, meaning
  that the response will not be cached;

* If ``Cache-Control`` is empty (but one of the other cache headers is present),
  its value is set to ``private, must-revalidate``;

* But if at least one ``Cache-Control`` directive is set, and no ``public`` or
  ``private`` directives have been explicitly added, Symfony adds the
  ``private`` directive automatically (except when ``s-maxage`` is set).

.. _http-expiration-validation:
.. _http-expiration-and-validation:

HTTP Expiration, Validation and Invalidation
--------------------------------------------

The HTTP specification defines two caching models:

* With the :doc:`expiration model </cache/expiration>`_, you simply specify
  how long a response should be considered "fresh" by including a ``Cache-Control``
  and/or an ``Expires`` header. Caches that understand expiration will not
  make the same request until the cached version reaches its expiration time
  and becomes "stale";

* When pages are really dynamic (i.e. their representation changes often),
  the :doc:`validation model </cache/validation>` is often necessary. With
  this model, the cache stores the response, but asks the server on each
  request whether or not the cached response is still valid. The application
  uses a unique response identifier (the ``Etag`` header) and/or a timestamp
  (the ``Last-Modified`` header) to check if the page has changed since being
  cached.

The goal of both models is to never generate the same response twice by relying
on a cache to store and return "fresh" responses. To achieve long caching times
but still provide updated content immediately, *cache invalidation* is
sometimes used.

.. sidebar:: Reading the HTTP Specification

    The HTTP specification defines a simple but powerful language in which
    clients and servers can communicate. As a web developer, the request-response
    model of the specification dominates your work. Unfortunately, the actual
    specification document - `RFC 2616`_ - can be difficult to read.

    There is an ongoing effort (`HTTP Bis`_) to rewrite the RFC 2616. It does
    not describe a new version of HTTP, but mostly clarifies the original HTTP
    specification. The organization is also improved as the specification
    is split into seven parts; everything related to HTTP caching can be
    found in two dedicated parts (`P4 - Conditional Requests`_ and `P6 -
    Caching: Browser and intermediary caches`_).

    As a web developer, you are strongly urged to read the specification. Its
    clarity and power - even more than ten years after its creation - is
    invaluable. Don't be put-off by the appearance of the spec - its contents
    are much more beautiful than its cover.

.. index::
   single: Cache; Vary
   single: HTTP headers; Vary

Varying the Response
~~~~~~~~~~~~~~~~~~~~

So far, it's been assumed that each URI has exactly one representation of the
target resource. By default, HTTP caching is done by using the URI of the
resource as the cache key. If two people request the same URI of a cacheable
resource, the second person will receive the cached version.

Sometimes this isn't enough and different versions of the same URI need to
be cached based on one or more request header values. For instance, if you
compress pages when the client supports it, any given URI has two representations:
one when the client supports compression, and one when it does not. This
determination is done by the value of the ``Accept-Encoding`` request header.

In this case, you need the cache to store both a compressed and uncompressed
version of the response for the particular URI and return them based on the
request's ``Accept-Encoding`` value. This is done by using the ``Vary`` response
header, which is a comma-separated list of different headers whose values
trigger a different representation of the requested resource:

.. code-block:: text

    Vary: Accept-Encoding, User-Agent

.. tip::

    This particular ``Vary`` header would cache different versions of each
    resource based on the URI and the value of the ``Accept-Encoding`` and
    ``User-Agent`` request header.

The ``Response`` object offers a clean interface for managing the ``Vary``
header::

    // set one vary header
    $response->setVary('Accept-Encoding');

    // set multiple vary headers
    $response->setVary(array('Accept-Encoding', 'User-Agent'));

The ``setVary()`` method takes a header name or an array of header names for
which the response varies.

.. index::
   pair: Cache; Configuration

More Response Methods
~~~~~~~~~~~~~~~~~~~~~

The Response class provides many more methods related to the cache. Here are
the most useful ones::

    // Marks the Response stale
    $response->expire();

    // Force the response to return a proper 304 response with no content
    $response->setNotModified();

Additionally, most cache-related HTTP headers can be set via the single
:method:`Symfony\\Component\\HttpFoundation\\Response::setCache` method::

    // Set cache settings in one call
    $response->setCache(array(
        'etag'          => $etag,
        'last_modified' => $date,
        'max_age'       => 10,
        's_maxage'      => 10,
        'public'        => true,
        // 'private'    => true,
    ));

.. index::
   single: Cache; Invalidation

.. _http-cache-invalidation:

Cache Invalidation
~~~~~~~~~~~~~~~~~~

    "There are only two hard things in Computer Science: cache invalidation
    and naming things." -- Phil Karlton

Once an URL is cached by a gateway cache, the cache will not ask the
application for that content anymore. This allows the cache to provide fast
responses and reduces the load on your application. However, you risk
delivering outdated content. A way out of this dilemma is to use long
cache lifetimes, but to actively notify the gateway cache when content
changes. Reverse proxies usually provide a channel to receive such
notifications, typically through special HTTP requests.

.. caution::

    While cache invalidation is powerful, avoid it when possible. If you fail
    to invalidate something, outdated caches will be served for a potentially
    long time. Instead, use short cache lifetimes or use the validation model,
    and adjust your controllers to perform efficient validation checks as
    explained in :ref:`optimizing-cache-validation`.

    Furthermore, since invalidation is a topic specific to each type of reverse
    proxy, using this concept will tie you to a specific reverse proxy or need
    additional efforts to support different proxies.

Sometimes, however, you need that extra performance you can get when
explicitly invalidating. For invalidation, your application needs to detect
when content changes and tell the cache to remove the URLs which contain
that data from its cache.

.. tip::

    If you want to use cache invalidation, have a look at the
    `FOSHttpCacheBundle`_. This bundle provides services to help with various
    cache invalidation concepts and also documents the configuration for a
    couple of common caching proxies.

If one content corresponds to one URL, the ``PURGE`` model works well.
You send a request to the cache proxy with the HTTP method ``PURGE`` (using
the word "PURGE" is a convention, technically this can be any string) instead
of ``GET`` and make the cache proxy detect this and remove the data from the
cache instead of going to the application to get a response.

Here is how you can configure the Symfony reverse proxy to support the
``PURGE`` HTTP method::

    // app/AppCache.php

    use Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    class AppCache extends HttpCache
    {
        protected function invalidate(Request $request, $catch = false)
        {
            if ('PURGE' !== $request->getMethod()) {
                return parent::invalidate($request, $catch);
            }

            if ('127.0.0.1' !== $request->getClientIp()) {
                return new Response(
                    'Invalid HTTP method',
                    Response::HTTP_BAD_REQUEST
                );
            }

            $response = new Response();
            if ($this->getStore()->purge($request->getUri())) {
                $response->setStatusCode(200, 'Purged');
            } else {
                $response->setStatusCode(404, 'Not found');
            }

            return $response;
        }
    }

.. caution::

    You must protect the ``PURGE`` HTTP method somehow to avoid random people
    purging your cached data.

**Purge** instructs the cache to drop a resource in *all its variants*
(according to the ``Vary`` header, see above). An alternative to purging is
**refreshing** a content. Refreshing means that the caching proxy is
instructed to discard its local cache and fetch the content again. This way,
the new content is already available in the cache. The drawback of refreshing
is that variants are not invalidated.

In many applications, the same content bit is used on various pages with
different URLs. More flexible concepts exist for those cases:

* **Banning** invalidates responses matching regular expressions on the
  URL or other criteria;
* **Cache tagging** lets you add a tag for each content used in a response
  so that you can invalidate all URLs containing a certain content.

Using Edge Side Includes
------------------------

When pages contain dynamic parts, you may not be able to cache entire pages,
but only parts of it. Read :doc:`/cache/esi` to find out how to configure
different cache strategies for specific parts of your page.

Summary
-------

Symfony was designed to follow the proven rules of the road: HTTP. Caching
is no exception. Mastering the Symfony cache system means becoming familiar
with the HTTP cache models and using them effectively. This means that, instead
of relying only on Symfony documentation and code examples, you have access
to a world of knowledge related to HTTP caching and gateway caches such as
Varnish.

Learn more
----------

.. toctree::
    :maxdepth: 1
    :glob:

    cache/*

.. _`Things Caches Do`: http://2ndscale.com/writings/things-caches-do
.. _`Cache Tutorial`: http://www.mnot.net/cache_docs/
.. _`Varnish`: https://www.varnish-cache.org/
.. _`Squid in reverse proxy mode`: http://wiki.squid-cache.org/SquidFaq/ReverseProxy
.. _`RFC 2616`: http://tools.ietf.org/html/rfc2616
.. _`HTTP Bis`: http://tools.ietf.org/wg/httpbis/
.. _`P4 - Conditional Requests`: http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional
.. _`P6 - Caching: Browser and intermediary caches`: http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache
.. _`FOSHttpCacheBundle`: http://foshttpcachebundle.readthedocs.org/
.. _`HTTP specification`: http://www.w3.org/Protocols/rfc2616/rfc2616.html
